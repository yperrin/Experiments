<html>
	<head>
		<title>Objects in Javascript</title>
	</head>
	<body>
	<p>
	Before starting anything else, it is a good idea to understand <a href="http://javascriptissexy.com/javascript-objects-in-detail">javascript objects</a>. Also good to know that all functions are objects.<br />
	Then here is a primer on the usage of <a href="http://javascriptissexy.com/javascript-prototype-in-plain-detailed-language">prototype</a>.<br />
	Javascript is both an <a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3">object oriented language</a> and a <a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-pt-2-functional-programming-a63aa53a41a4">functional programming language</a><br />
	<ul>
		<li>Objects are just a list of properties (primitives) and methods (functions) <pre>var myFirstObject = {firstName: "Richard", favoriteAuthor: "Conrad"};
var obj = {}; is equivalent to var obj = new Object();
Array has its own prototype and ovewrites some of Object methods. Also has a constructor property.
		</pre></li>
		<li>properties can be accesses using myObject.name or myObject["name"]</li>
		<li>functions are objects (inheriting from Function?). It can be called directly, not all objects are functions. However functions can also have properties as they are objects.</li>
		<li>Each data property (object property that store data) has not only the name-value pair, but also 3 attributes (the three attributes are set to true by default) Configurable Attribute (Specifies whether the property can be deleted or changed), Enumerable (Specifies whether the property can be returned in a for/in loop) and Writable (Specifies whether the property can be changed)</li>
		<li>Objects can be created using <pre>var mango = { color: "yellow", shape: "round", sweetness: 8 }</pre> or <pre>var mango =  new Object (); mango.color = "yellow"; mango.shape= "round";</pre></li>
		<li>All objects have a prototype property which represents the inherited properties. You can assign properties and functions the same way you would do with any other object. Prototype has 2 purposes. prototype property where you can store things and the one which is delegated to when a method/property cannot be found.</li>
		<li>To find out if a property exists on an object (either as an inherited or an own property), you use the in operator <pre>"schoolName" in school</pre></li>
		<li>To find out if an object has a specific property as one of its own property, you use the hasOwnProperty method <pre>school.hasOwnProperty ("schoolName")</pre></li>
		<li>Properties inherited from Object.prototype are not enumerable, so the for/in loop does not show them. However, inherited properties that are enumerable are revealed in the for/in loop iteration.</li>
		<li>Closures are in effect when a function access data from parent context. This can be used to create data privacy.
<pre>
var counter = function counter() {
  var count = 0;
  return {
    getCount: function getCount() {
      return count;
    },
    increment: function increment() {
      count += 1;
    }
  };
};
</pre>		
		</li>
	</ul>
	</p>
	<p>Udacity  classes Object-Oriented JavaScript
	<ul>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2593668699/m-2780408563">this keyword</a><pre>resolved at call time obj.method() this is obj. 
It can be overwritten using object.method.call(newthis, [params])</li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2593668700/m-2616738615">Prototype Chains</a><pre>var blue = extend({}, gold); //on time copy of properties
var blue = Object.create(gold); //this will use prototype chain. Any changes to gold will be reflected in blue.
Object has toString(), hasOwnProperty(), constructor
		</pre></li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2794468536/m-2697628561">Object Decorator Pattern</a>
<pre>
var carlike = function(obj, loc) {
    obj.loc = loc;
    obj.move = function() {
        loc++;
    };
    return obj;
};
var amy = carlike({}, 1);
amy.move();

//could be expensive as a new version of move() is created. Could define move as a separate function and just set the reference
var carlike = function(obj, loc) {
    obj.loc = loc;
    obj.move = move;
    return obj;
};
//better to use method described below (Functional classes) to define the functions
var move = function() {
	this.loc++:
}
var amy = carlike({}, 1);
amy.move();
</pre>
		</li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2794468537/m-2961989110">Functional Classes</a>
<pre>
var Car = function(loc) {
  var obj = { loc: loc};
  $.extend(obj, Car.methods); //even though we are extending, we are only copying method references and thus not adding to the memory
  return obj;
}
Car.methods = {
  move: function() {
    this.loc++;
  }
 }
var ben = Car(9);
ben.move();
</pre>
		</li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2794468538/m-3034538557">Prototypal Classes</a>
<pre>
var Car = function(loc) {
	var obj = Object.create(Car.prototype); //because we are using 
	obj.loc = loc;
	return obj;
}
Car.prototype.move = function() { //using it as built in property to store things. Could have chosen a different name.
	this.loc++;
};
var ben = Car(9);
ben.move();
</pre>
		</li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2794468539/e-2783098540/m-2695768694">Pseudoclassical Patterns</a>
<pre>
new keywork is equivalent to this = Object.create(Car.prototype); and return this;

var Car = function(loc) {
	//instance specific data and methods
	this.loc = loc;
}
//common class data and methods
Car.prototype.move = function() { 
	this.loc++;
};
var ben = Car(9);
ben.move();
</pre>
	</li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2794468540/m-2785128536">Superclass and Subclasses Functional approach</a>
<pre>
var Car = function(loc) {
	var obj = {loc: loc};
	obj.move = function() {...};
	return obj;
}
var Van = function(loc) {
	var obj = Car(loc);
	obj.grab = function() {...};
	return obj;
}
</pre>
		</li>
		<li><a href="https://www.udacity.com/course/viewer#!/c-ud015/l-2794468541/e-2693158566/m-2688408703">Pseudoclassical Subclasses</a>
<pre>
var Car = function(loc) {
	obj.loc = loc;
}
Car.prototype.move = function() {...};

var Van = function(loc) {
	Car.call(this, loc);
}
Van.prototype = Object.create(Car.prototype);
Van.prototype.constructor = Van;
Van.prototype.grab = function() {...};
</pre>
		</li>
	</ul>
	</p>
	<p> Here is some <a href="https://developers.google.com/speed/articles/optimizing-javascript#Initializing instance variables">optimization article</a> worth reading</p>
	<p>
	<h2>A look at JQuery</h2>
The JQuery object is initialized through a function and JQuery as well as $ are global variables set to the JQuery object.
<pre>
(function( window, undefined ) {
	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},
})( window );
</pre>
<pre>
		jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},
</pre>
functions are stored in fn object under JQuery object
<pre>
Query.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: core_version,

	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem;
		...
		return jQuery.makeArray( selector, this );
	},
</pre>
	</p>
	<p>
	<h2>Recommendations</h2>
	Inheritance can be tricky, favor composition over inheritance.<br />
	For creating a library of util methods, create a namespace to avoid overwriting other objects in Global scope. Each module cna be in its own js if needed and will be added to original object as needed.This is a good approach:
<pre>
window.asi = window.asi || {};
asi.modal = asi.modal || {};
(function (modal, $, undefined) {
	modal.function1 = function(params) {...}; //for public methods
	modal.value1 = ""; //for public variables
	var value1 = ""; //for private variables
	function function2() {...}; //for private methods
})(asi.modal, JQuery);
</pre>
	</p>
	<script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
	<script>
		var myFunction = function() {console.log(this)};
		console.log("Checking function object");
		console.log(myFunction);
		var basicTest = {};
		basicTest = new Object();
		console.log("new Object() prototype is " + basicTest.prototype);
		
		function FirstTest(aValue) {
			var value = aValue;
			this.aValue = aValue;
			this.anArray = [1,0];
			this.print = function() {
				console.log("local print method: " + this.aValue + " and array " + this.anArray[1] + " internal value: " + value);
			}
		};
		FirstTest.prototype.otherValue = "other value";
		FirstTest.prototype.otherPrint = function() {
			console.log("prototype print method: " + this.aValue + ":" + this.otherValue);
		};
		var firstTest = new FirstTest("constructor value");
		var secondTest = new FirstTest("second constructor");
		firstTest.otherValue = "Other Value changed";
		firstTest.anArray[1] = 5;
		firstTest.print();
		firstTest.otherPrint();
		console.log("firstTest prototype is " + firstTest.prototype);
		console.log("firstTest instanceof FirstTest " + (firstTest instanceof FirstTest));
		console.log("firstTest instanceof Object " + (firstTest instanceof Object));
		secondTest.print();
		secondTest.otherPrint();
		console.log("secondTest prototype is " + secondTest.prototype);
		console.log("secondTest instanceof FirstTest " + (secondTest instanceof FirstTest));
		console.log("secondTest instanceof Object " + (secondTest instanceof Object));
		
		var SecondTest = function(defaultValue) {
			var value = defaultValue;
			this.aValue = "default";
			printInternal = function() {
				console.log("internal value: " + value + " public value: " + this.aValue);
			};
			return {
				print : function() { printInternal() }
			};
		};
		var a = SecondTest("constructor default");
		a.print();
		a.value = "test overwrite";
		a.aValue = "overwrite public";
		a.print();
		
		var Car = function(loc) {
		  var obj = { loc: loc};
		  $.extend(obj, Car.methods); //even though we are extending, we are only copying method references and thus not adding to the memory
		  return obj;
		}
		Car.methods = {
		  move: function() {
			this.loc++;
		  }
		 }
		var ben = Car(9);
		ben.move();		
		
		Car = function(loc) {
		  var obj = Object.create(Car.methods);
		  obj.loc = loc;
		  return obj;
		}
		Car.methods = {
		  move: function() {
			this.loc++;
		  }
		 }
		ben = Car(9);
		ben.move();	
		</script>
	</body>
</html>